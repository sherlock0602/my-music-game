<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Neon Beat - 3D Perspective</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        /* --- 基礎設定 --- */
        * { -webkit-tap-highlight-color: transparent; -webkit-touch-callout: none; user-select: none; touch-action: none; box-sizing: border-box; outline: none; }
        body { margin: 0; background: #000; color: white; overflow: hidden; font-family: 'Orbitron', sans-serif; width: 100vw; height: 100vh; position: fixed; }

        /* --- 背景 (深空) --- */
        #bg { 
            position: absolute; inset: 0; z-index: 0; 
            background: radial-gradient(circle at 50% 30%, #111 0%, #000 80%);
        }
        /* 飄浮粒子背景 */
        #stars { position: absolute; inset: 0; z-index: 0; pointer-events: none; }

        /* --- UI 層 (模仿圖片佈局) --- */
        #ui-layer { 
            position: absolute; top: 5%; width: 100%; text-align: center; pointer-events: none; z-index: 10; 
            display: flex; flex-direction: column; align-items: center;
        }
        h1 { margin: 0; font-size: 30px; color: #0ff; text-shadow: 0 0 20px #0ff; letter-spacing: 5px; opacity: 0.8; }
        
        #combo-container { margin: 10px 0; }
        #combo-num { font-size: 80px; font-weight: 900; line-height: 1; color: #fff; text-shadow: 0 0 30px #0ff; margin: 0; }
        #score-text { font-size: 14px; color: #aaa; letter-spacing: 2px; margin-top: 5px; }
        
        #judgement { 
            font-size: 24px; font-weight: bold; height: 30px; margin-top: 10px; 
            padding: 5px 20px; border: 1px solid rgba(0,255,255,0.3); background: rgba(0,0,0,0.5);
            opacity: 0; transition: transform 0.1s; letter-spacing: 3px;
        }

        /* --- 載入畫面 --- */
        #loader-layer { 
            position: absolute; inset: 0; z-index: 100; background: #000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.5s;
        }
        #status-text { color: #0ff; font-size: 16px; margin-bottom: 30px; animation: pulse 1.5s infinite; }
        @keyframes pulse { 50% { opacity: 0.5; } }
        #start-btn {
            padding: 15px 60px; font-size: 20px; font-weight: 900; color: #000; background: #0ff;
            border: none; border-radius: 50px; cursor: pointer; font-family: 'Orbitron';
            box-shadow: 0 0 40px #0ff; display: none;
        }

        /* --- 圓形按鈕區 (模仿圖片) --- */
        #controls { 
            position: absolute; bottom: 5%; left: 50%; transform: translateX(-50%);
            display: flex; gap: 20px; z-index: 20;
        }
        .key-btn {
            width: 70px; height: 70px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(0, 0, 0, 0.5);
            display: flex; align-items: center; justify-content: center;
            font-size: 24px; font-weight: bold; color: rgba(255, 255, 255, 0.7);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            transition: 0.05s; backdrop-filter: blur(5px);
        }
        .key-btn.active {
            border-color: #0ff; color: #fff; background: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 30px #0ff, inset 0 0 20px #0ff; transform: scale(0.9);
        }

        canvas { display: block; position: absolute; inset: 0; z-index: 5; }

        /* 進度條 (頂部細線) */
        #progress-container { position: absolute; top: 0; left: 0; width: 100%; height: 3px; background: #222; z-index: 50; }
        #progress-bar { width: 0%; height: 100%; background: #0ff; box-shadow: 0 0 10px #0ff; }
    </style>
</head>
<body>

    <div id="bg"></div>
    <div id="progress-container"><div id="progress-bar"></div></div>

    <div id="loader-layer">
        <h1 style="font-size: 50px; margin-bottom: 20px;">NEON BEAT</h1>
        <div id="status-text">SYSTEM INITIALIZING...</div>
        <button id="start-btn" onclick="startGame()">START GAME</button>
        <p style="color: #444; font-size: 12px; margin-top: 20px;">Reading: music.mp3</p>
    </div>

    <div id="ui-layer">
        <h1>NEON BEAT</h1>
        <div id="combo-container">
            <p id="score-text">SCORE: 0</p>
            <p id="combo-num">0</p>
        </div>
        <div id="judgement">READY</div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="controls">
        <div class="key-btn" id="btn-0">D</div>
        <div class="key-btn" id="btn-1">F</div>
        <div class="key-btn" id="btn-2">J</div>
        <div class="key-btn" id="btn-3">K</div>
    </div>

<script>
// --- 設定區 ---
const MUSIC_URL = 'music.mp3';
const OFFSET = 0;              
const LEAD_TIME = 1200;        // 音符飛行時間
// 圖片中的配色: 藍(D), 綠(F), 藍(J), 紅/橘(K) - 這裡做一點調整讓視覺更豐富
const COLORS = ['#00FFFF', '#00FF66', '#FF0055', '#FFAA00']; 
const LANE_KEYS = ['d', 'f', 'j', 'k'];

// --- 3D 透視參數 ---
// 軌道上緣寬度 (消失點附近)
let TOP_WIDTH_RATIO = 0.1; 
// 軌道下緣寬度 (判定線附近)
let BOTTOM_WIDTH_RATIO = 0.8; 
// 判定線在畫面 Y 軸的位置 (0~1)
let HIT_LINE_Y = 0.85; 
// 軌道起點 Y 軸 (0~1)
let TRACK_START_Y = 0.25;

// --- 系統變數 ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const comboEl = document.getElementById('combo-num');
const scoreEl = document.getElementById('score-text');
const judgeEl = document.getElementById('judgement');
const progressEl = document.getElementById('progress-bar');
const statusText = document.getElementById('status-text');
const startBtn = document.getElementById('start-btn');
const loaderLayer = document.getElementById('loader-layer');

let audioCtx, audioBuffer, audioSource;
let isPlaying = false, startTime = 0;
let generatedNotes = [], activeNotes = [];
let combo = 0, score = 0;
let activeKeys = [false, false, false, false];
let particles = []; // 打擊特效粒子

// --- 1. 初始化 ---
window.onload = async function() {
    resize();
    window.addEventListener('resize', resize);
    
    // 預先生成一些背景星星
    initBackgroundStars();

    try {
        statusText.innerText = "DOWNLOADING TRACK...";
        const response = await fetch(MUSIC_URL);
        if (!response.ok) throw new Error("找不到 music.mp3");
        
        const arrayBuffer = await response.arrayBuffer();
        statusText.innerText = "ANALYZING SPECTRUM...";
        
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        audioCtx.decodeAudioData(arrayBuffer, (buffer) => {
            audioBuffer = buffer;
            analyzeBeats(buffer);
        }, () => { throw new Error("Decode Error"); });

    } catch (err) {
        statusText.style.color = "#ff3333";
        statusText.innerText = "ERROR: music.mp3 NOT FOUND";
    }
};

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}

// 背景星星
let bgStars = [];
function initBackgroundStars() {
    for(let i=0; i<100; i++) {
        bgStars.push({
            x: Math.random() * window.innerWidth,
            y: Math.random() * window.innerHeight,
            size: Math.random() * 2,
            opacity: Math.random()
        });
    }
}

// --- 2. 節拍分析 (保留之前的強力算法) ---
function analyzeBeats(buffer) {
    const rawData = buffer.getChannelData(0);
    const sampleRate = buffer.sampleRate;
    const step = Math.floor(sampleRate / 60); 
    
    generatedNotes = [];
    
    let sum = 0, count = 0;
    for (let i = 0; i < rawData.length; i += step) {
        sum += Math.abs(rawData[i]);
        count++;
    }
    const threshold = (sum / count) * 1.6;

    let lastIndex = -10000;
    const minDistance = sampleRate * 0.35; 

    for (let i = 0; i < rawData.length; i += step) {
        if (Math.abs(rawData[i]) > threshold && (i - lastIndex) > minDistance) {
            const timeMs = (i / sampleRate) * 1000;
            generatedNotes.push({
                time: timeMs,
                lane: Math.floor(Math.random() * 4),
                hit: false
            });
            lastIndex = i;
        }
    }

    statusText.innerText = `READY: ${generatedNotes.length} BEATS`;
    statusText.style.animation = "none";
    statusText.style.color = "#fff";
    startBtn.style.display = "block";
}

// --- 3. 遊戲核心 ---
function startGame() {
    if(!audioBuffer) return;
    loaderLayer.style.opacity = 0;
    setTimeout(() => loaderLayer.style.display = 'none', 500);

    activeNotes = JSON.parse(JSON.stringify(generatedNotes));
    
    audioSource = audioCtx.createBufferSource();
    audioSource.buffer = audioBuffer;
    audioSource.connect(audioCtx.destination);
    
    startTime = audioCtx.currentTime * 1000 + LEAD_TIME;
    audioSource.start(audioCtx.currentTime + (LEAD_TIME / 1000));
    
    isPlaying = true;
    requestAnimationFrame(gameLoop);
}

// --- 4. 關鍵：3D 透視繪圖引擎 ---

// 計算某個進度 (0=遠處, 1=判定線) 在螢幕上的 X, Y, 寬度
function getPerspective(laneIndex, progress) {
    // 限制 progress 範圍以免跑出畫面太遠
    // progress 0 是軌道起點(上方), 1 是判定線(下方)
    
    const centerY = canvas.height * TRACK_START_Y;
    const endY = canvas.height * HIT_LINE_Y;
    const trackHeight = endY - centerY;

    const currentY = centerY + (trackHeight * progress);
    
    // 計算當前 Y 的軌道總寬度
    const maxW = canvas.width * BOTTOM_WIDTH_RATIO;
    const minW = canvas.width * TOP_WIDTH_RATIO;
    
    // 簡單線性插值：越往下越寬
    const currentTotalWidth = minW + (maxW - minW) * progress;
    const laneWidth = currentTotalWidth / 4;
    
    // 計算該軌道的中心 X
    const screenCenterX = canvas.width / 2;
    const trackLeftX = screenCenterX - (currentTotalWidth / 2);
    
    const x = trackLeftX + (laneIndex * laneWidth);
    
    return { x, y: currentY, w: laneWidth };
}

function gameLoop() {
    if(!isPlaying) return;
    const now = (audioCtx.currentTime * 1000) - startTime + LEAD_TIME;

    // UI 更新
    if(audioBuffer) {
        const pct = (now / (audioBuffer.duration * 1000)) * 100;
        progressEl.style.width = Math.min(100, pct) + "%";
        if(pct > 100) isPlaying = false;
    }

    // 清空畫面
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // 繪製背景星星
    ctx.fillStyle = '#fff';
    bgStars.forEach(s => {
        ctx.globalAlpha = Math.random() * 0.5 + 0.3;
        ctx.fillRect(s.x, s.y, s.size, s.size);
    });
    ctx.globalAlpha = 1;

    // --- 繪製 3D 軌道 ---
    // 畫 5 條線 (4 個軌道的邊界)
    ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
    ctx.lineWidth = 2;
    ctx.shadowBlur = 10;
    ctx.shadowColor = '#0ff';
    
    for(let i=0; i<=4; i++) {
        const startP = getPerspective(i, 0); // 遠處
        const endP = getPerspective(i, 1.1); // 近處 (延伸一點超出判定線)
        
        ctx.beginPath();
        ctx.moveTo(startP.x, startP.y);
        ctx.lineTo(endP.x, endP.y);
        ctx.stroke();
    }
    ctx.shadowBlur = 0;

    // 繪製判定線 (橫線)
    const pLeft = getPerspective(0, 1);
    const pRight = getPerspective(4, 1);
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
    ctx.beginPath();
    ctx.moveTo(pLeft.x, pLeft.y);
    ctx.lineTo(pRight.x + pRight.w, pRight.y); // pRight 是第4條線起點，要加寬度才到右邊界
    ctx.stroke();

    // 繪製按鍵發光回饋 (光束)
    activeKeys.forEach((isActive, i) => {
        if(isActive) {
            const pStart = getPerspective(i, 0);
            const pEnd = getPerspective(i, 1);
            
            // 形成一個梯形光束
            ctx.fillStyle = COLORS[i];
            ctx.globalAlpha = 0.2;
            ctx.beginPath();
            ctx.moveTo(pStart.x, pStart.y);
            ctx.lineTo(pStart.x + pStart.w, pStart.y);
            ctx.lineTo(pEnd.x + pEnd.w, pEnd.y);
            ctx.lineTo(pEnd.x, pEnd.y);
            ctx.fill();
            ctx.globalAlpha = 1;
            
            // 底部高亮
            ctx.fillStyle = COLORS[i];
            ctx.shadowBlur = 20; ctx.shadowColor = COLORS[i];
            ctx.fillRect(pEnd.x, pEnd.y - 2, pEnd.w, 4);
            ctx.shadowBlur = 0;
        }
    });

    // --- 繪製音符 ---
    activeNotes.forEach(n => {
        if(n.hit) return;
        
        // 計算進度 (0~1)
        // 進度 = 1 - (剩餘時間 / 總飛行時間)
        const timeRemaining = (n.time + OFFSET) - now;
        const progress = 1 - (timeRemaining / LEAD_TIME);
        
        if (progress > 0 && progress < 1.2) {
            // 音符是一個梯形 (模擬3D厚度)
            const p = getPerspective(n.lane, progress);
            
            // 根據圖片，音符有 "拖尾" 效果，所以我們取稍早一點的點做尾巴
            const tailProgress = progress - 0.15; // 尾巴長度
            const pTail = getPerspective(n.lane, Math.max(0, tailProgress));

            ctx.fillStyle = COLORS[n.lane];
            ctx.shadowBlur = 15;
            ctx.shadowColor = COLORS[n.lane];
            
            ctx.beginPath();
            // 頂部 (遠端)
            ctx.moveTo(pTail.x + 5, pTail.y);
            ctx.lineTo(pTail.x + pTail.w - 5, pTail.y);
            // 底部 (近端)
            ctx.lineTo(p.x + p.w - 2, p.y);
            ctx.lineTo(p.x + 2, p.y);
            ctx.fill();
            
            ctx.shadowBlur = 0;
        }

        // Miss 判定
        if (timeRemaining < -200) {
            n.hit = true;
            combo = 0; comboEl.innerText = 0;
            showJudge("MISS", "#555");
        }
    });

    // --- 粒子特效 ---
    updateParticles();

    requestAnimationFrame(gameLoop);
}

// --- 粒子系統 (模仿圖片底部的爆發) ---
function createExplosion(lane) {
    const p = getPerspective(lane, 1);
    const centerX = p.x + p.w / 2;
    const centerY = p.y;
    const color = COLORS[lane];

    for(let i=0; i<15; i++) {
        particles.push({
            x: centerX, y: centerY,
            vx: (Math.random() - 0.5) * 10,
            vy: (Math.random() - 1) * 15, // 向上噴發
            life: 1,
            color: color,
            size: Math.random() * 4 + 2
        });
    }
}

function updateParticles() {
    for(let i=particles.length-1; i>=0; i--) {
        let p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.5; // 重力
        p.life -= 0.05;
        
        if(p.life <= 0) {
            particles.splice(i, 1);
        } else {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
            ctx.fill();
        }
    }
    ctx.globalAlpha = 1;
}

// --- 輸入處理 ---
function handleInput(lane, isDown) {
    if(lane < 0 || lane >= 4) return;
    activeKeys[lane] = isDown;
    const btn = document.getElementById(`btn-${lane}`);
    if(btn) btn.classList.toggle('active', isDown);

    if(isDown && isPlaying) {
        const now = (audioCtx.currentTime * 1000) - startTime + LEAD_TIME;
        
        const note = activeNotes.find(n => !n.hit && n.lane === lane && Math.abs((n.time + OFFSET) - now) < 160);
        
        if(note) {
            note.hit = true;
            combo++;
            score += 100 + combo * 10;
            comboEl.innerText = combo;
            scoreEl.innerText = `SCORE: ${score}`;
            
            // 判定
            const err = Math.abs((note.time + OFFSET) - now);
            if(err < 50) showJudge("PERFECT", "#0ff");
            else showJudge("GOOD", "#ff0");

            // 特效
            createExplosion(lane);
        }
    }
}

function showJudge(text, color) {
    judgeEl.innerText = text;
    judgeEl.style.color = color;
    judgeEl.style.borderColor = color;
    judgeEl.style.boxShadow = `0 0 15px ${color}`;
    judgeEl.style.opacity = 1;
    judgeEl.style.transform = "scale(1.2)";
    setTimeout(() => { judgeEl.style.transform = "scale(1)"; judgeEl.style.opacity = 0; }, 200);
}

// 綁定事件
LANE_KEYS.forEach((k, i) => {
    const el = document.getElementById(`btn-${i}`);
    el.addEventListener('touchstart', (e)=>{ e.preventDefault(); handleInput(i, true); });
    el.addEventListener('touchend', (e)=>{ e.preventDefault(); handleInput(i, false); });
    // 滑鼠點擊支援
    el.addEventListener('mousedown', (e)=>{ e.preventDefault(); handleInput(i, true); });
    el.addEventListener('mouseup', (e)=>{ e.preventDefault(); handleInput(i, false); });
});
window.addEventListener('keydown', e => {
    const i = LANE_KEYS.indexOf(e.key.toLowerCase());
    if(i > -1 && !activeKeys[i]) handleInput(i, true);
});
window.addEventListener('keyup', e => {
    const i = LANE_KEYS.indexOf(e.key.toLowerCase());
    if(i > -1) handleInput(i, false);
});
</script>
</body>
</html>
