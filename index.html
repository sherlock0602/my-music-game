<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Neon Beat - Stable Core</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;900&display=swap');

        /* 核心防錯設置 */
        * { 
            -webkit-tap-highlight-color: transparent; 
            -webkit-touch-callout: none; 
            -webkit-user-select: none; 
            user-select: none; 
            outline: none; 
            box-sizing: border-box;
            touch-action: none; 
        }

        body { 
            margin: 0; background: #000; color: white; overflow: hidden; 
            font-family: 'Orbitron', sans-serif; position: fixed; width: 100%; height: 100%;
        }

        /* 3D 背景 */
        #bg-grid {
            position: absolute; inset: 0;
            background-image: linear-gradient(rgba(0, 255, 255, 0.1) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(0, 255, 255, 0.1) 1px, transparent 1px);
            background-size: 40px 40px;
            transform: perspective(600px) rotateX(70deg);
            transform-origin: center bottom;
            z-index: 0;
            animation: grid-move 1s linear infinite;
            opacity: 0.5;
        }
        @keyframes grid-move { from { background-position: 0 0; } to { background-position: 0 40px; } }

        /* 遊戲 UI */
        #ui { position: absolute; top: 40px; width: 100%; text-align: center; pointer-events: none; z-index: 10; }
        #score-display { font-size: 16px; letter-spacing: 2px; color: #0ff; text-shadow: 0 0 10px #0ff; }
        #combo { font-size: 80px; font-weight: 900; margin: 0; color: #fff; text-shadow: 0 0 30px rgba(0,255,255,0.8); }
        
        #judgement { 
            height: 40px; font-weight: 900; font-size: 28px; letter-spacing: 5px; 
            margin-top: 10px; opacity: 0; transition: opacity 0.1s;
        }

        /* 倒數與進度條 */
        #timer-container { position: absolute; top: 20px; right: 20px; width: 140px; z-index: 15; }
        #time-text { font-size: 16px; color: #fff; text-align: right; margin-bottom: 5px; font-weight: bold; }
        #progress-bar { width: 100%; height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px; }
        #progress-fill { width: 0%; height: 100%; background: #0ff; box-shadow: 0 0 10px #0ff; transition: width 0.2s; }

        /* 操作區 (平板優化) */
        #touch-controls { 
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; justify-content: center; z-index: 20;
        }
        .touch-btn {
            height: 120px; /* 大按鈕 */
            margin: 0 6px; 
            border: 2px solid rgba(0, 255, 255, 0.2); 
            border-radius: 12px;
            display: flex; align-items: flex-end; justify-content: center;
            background: rgba(0, 20, 20, 0.8); 
            backdrop-filter: blur(5px); 
            padding-bottom: 15px;
            transition: transform 0.05s, background 0.05s;
        }
        .touch-btn span { font-size: 30px; font-weight: 900; color: rgba(255,255,255,0.5); }
        .touch-btn.active { background: #0ff; border-color: #fff; transform: scale(0.95); }
        .touch-btn.active span { color: #000; }

        /* 開始選單 */
        .overlay { position: absolute; inset: 0; background: #000; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; }
        .btn-start { 
            padding: 20px 60px; font-size: 24px; cursor: pointer; background: #0ff; color: #000; 
            border: none; font-family: 'Orbitron'; font-weight: 900; letter-spacing: 2px;
            box-shadow: 0 0 30px rgba(0,255,255,0.5); border-radius: 5px;
        }
        .btn-start:active { transform: scale(0.95); }
    </style>
</head>
<body>

    <div id="bg-grid"></div>

    <div id="start-overlay" class="overlay">
        <h1 style="font-size: 60px; color: #fff; text-shadow: 0 0 20px #0ff; margin-bottom: 40px;">NEON BEAT</h1>
        <button class="btn-start" onclick="startGame()">TAP TO START</button>
        <p style="color: #666; margin-top: 20px;">Ensure Silent Mode is OFF</p>
    </div>

    <div id="timer-container">
        <div id="time-text">00:00</div>
        <div id="progress-bar"><div id="progress-fill"></div></div>
    </div>

    <div id="ui">
        <p id="score-display">SCORE: 0</p>
        <p id="combo">0</p>
        <div id="judgement">PERFECT</div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="touch-controls">
        <div class="touch-btn" id="btn-0"><span>D</span></div>
        <div class="touch-btn" id="btn-1"><span>F</span></div>
        <div class="touch-btn" id="btn-2"><span>J</span></div>
        <div class="touch-btn" id="btn-3"><span>K</span></div>
    </div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const comboEl = document.getElementById('combo');
const scoreEl = document.getElementById('score-display');
const judgeEl = document.getElementById('judgement');
const timeText = document.getElementById('time-text');
const progFill = document.getElementById('progress-fill');

// --- 核心設定 ---
let laneWidth, startX, judgeY;
const LANES = 4;
const COLORS = ['#FF0055', '#00FBFF', '#BCFF00', '#FF9500']; // 紅, 藍, 綠, 橘
const LANE_KEYS = ['d', 'f', 'j', 'k'];

// --- 遊戲參數 (BPM 模式) ---
const BPM = 130; // 這裡控制生成速度！數字越大越快
const BEAT_INTERVAL = 60000 / BPM; 
const LEAD_TIME = 1500; // 音符掉落需要的時間 (毫秒)
const NOTE_SPEED = 0.8; // 下落視覺速度

let audioCtx, audio;
let startTime = 0, isPlaying = false;
let combo = 0, score = 0;
let notes = []; // 存放所有音符
let nextSpawnTime = 0; // 下一次生成音符的時間
let activeKeys = [false, false, false, false];
let hitEffects = [];

// 初始化大小
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    laneWidth = Math.min(120, canvas.width / 4.2); // 平板寬度優化
    startX = (canvas.width - (laneWidth * LANES)) / 2;
    judgeY = canvas.height * 0.75; // 判定線位置

    const controls = document.getElementById('touch-controls');
    controls.style.width = `${laneWidth * LANES}px`;
    LANE_KEYS.forEach((_, i) => {
        document.getElementById(`btn-${i}`).style.width = `${laneWidth - 12}px`;
    });
}

async function startGame() {
    resize();
    window.addEventListener('resize', resize);
    
    // 初始化 Audio Context (即使沒有載入成功，遊戲也要能玩)
    try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        audio = new Audio('your_music.mp3'); // 請換成你的音樂連結
        audio.crossOrigin = "anonymous";
        
        // 嘗試連接節點 (僅用於播放)
        const source = audioCtx.createMediaElementSource(audio);
        source.connect(audioCtx.destination);
        
        await audio.play();
    } catch (e) {
        console.warn("Audio init failed or no music found, running in silent mode.");
    }

    document.getElementById('start-overlay').style.display = 'none';
    
    startTime = performance.now();
    nextSpawnTime = 0; // 重置生成計時器
    isPlaying = true;
    requestAnimationFrame(gameLoop);
}

function gameLoop() {
    if(!isPlaying) return;
    const now = performance.now() - startTime;
    const songTime = audio ? audio.currentTime : now / 1000;
    const duration = audio ? audio.duration : 180;

    // --- 1. 穩定的音符生成器 (BPM Based) ---
    // 只要當前時間超過了預定的生成時間，就產生一個音符
    if (now > nextSpawnTime) {
        // 隨機決定產生幾個音符 (單押或雙押)
        const count = Math.random() > 0.8 ? 2 : 1; 
        const lanes = [0, 1, 2, 3].sort(() => 0.5 - Math.random()).slice(0, count);
        
        lanes.forEach(lane => {
            notes.push({
                lane: lane,
                targetTime: now + LEAD_TIME, // 設定這個音符要在 LEAD_TIME 後到達判定線
                hit: false
            });
        });

        // 設定下一次生成時間 (隨機節奏變化：1拍, 0.5拍, 或 2拍)
        const rhythm = Math.random();
        let multiplier = 1;
        if (rhythm > 0.9) multiplier = 0.5; // 快速連打
        else if (rhythm < 0.1) multiplier = 2; // 停頓
        
        nextSpawnTime += BEAT_INTERVAL * multiplier;
    }

    // --- 2. 畫面繪製 ---
    ctx.clearRect(0, 0, canvas.width, canvas.height); // 清空畫布

    // 繪製軌道與判定線
    LANE_KEYS.forEach((_, i) => {
        const x = startX + i * laneWidth;
        
        // 軌道背景 (按下時發光)
        if (activeKeys[i]) {
            const grad = ctx.createLinearGradient(0, judgeY, 0, 0);
            grad.addColorStop(0, COLORS[i]);
            grad.addColorStop(1, 'transparent');
            ctx.fillStyle = grad;
            ctx.globalAlpha = 0.3;
            ctx.fillRect(x + 2, 0, laneWidth - 4, judgeY);
            ctx.globalAlpha = 1.0;
        }

        // 判定框
        ctx.strokeStyle = activeKeys[i] ? '#fff' : 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 4;
        ctx.strokeRect(x + 4, judgeY, laneWidth - 8, 4);
    });

    // 繪製音符
    notes.forEach(n => {
        if (n.hit) return; // 打過的就不畫

        const timeDiff = n.targetTime - now; // 距離被打擊還剩多久
        const y = judgeY - (timeDiff * NOTE_SPEED); // 計算 Y 軸位置
        const x = startX + n.lane * laneWidth;

        // 只繪製在畫面內的
        if (y > -50 && y < canvas.height) {
            ctx.fillStyle = COLORS[n.lane];
            // 繪製發光效果
            ctx.shadowBlur = 20;
            ctx.shadowColor = COLORS[n.lane];
            
            // 音符本體
            ctx.beginPath();
            ctx.roundRect(x + 10, y - 10, laneWidth - 20, 20, 6);
            ctx.fill();
            
            ctx.shadowBlur = 0; // 關閉陰影以節省效能
        }

        // Miss 判定 (超過判定線 200ms)
        if (timeDiff < -200 && !n.hit) {
            n.hit = true;
            resetCombo();
        }
    });

    // 繪製打擊特效 (爆炸波紋)
    hitEffects.forEach((eff, i) => {
        ctx.beginPath();
        ctx.arc(eff.x, eff.y, eff.r, 0, Math.PI*2);
        ctx.strokeStyle = eff.color;
        ctx.lineWidth = 4;
        ctx.globalAlpha = eff.life;
        ctx.stroke();
        
        eff.r += 5; // 半徑變大
        eff.life -= 0.05; // 透明度降低
        if (eff.life <= 0) hitEffects.splice(i, 1);
    });
    ctx.globalAlpha = 1.0;

    // --- 3. UI 更新 ---
    if (duration) {
        timeText.innerText = formatTime(songTime);
        progFill.style.width = `${(songTime / duration) * 100}%`;
    }

    requestAnimationFrame(gameLoop);
}

// --- 輸入處理 ---
function handleInput(lane, isDown) {
    if (lane < 0 || lane >= LANES) return;
    activeKeys[lane] = isDown;
    const btn = document.getElementById(`btn-${lane}`);
    if(btn) btn.classList.toggle('active', isDown);

    if (isDown && isPlaying) {
        const now = performance.now() - startTime;
        // 尋找判定區內的音符 (前後 180ms)
        const note = notes.find(n => !n.hit && n.lane === lane && Math.abs(n.targetTime - now) < 180);

        if (note) {
            note.hit = true; // 標記為已擊中
            combo++;
            score += 100 + combo * 10;
            
            // 更新 UI
            comboEl.innerText = combo;
            comboEl.style.transform = "scale(1.2)";
            setTimeout(() => comboEl.style.transform = "scale(1)", 100);
            
            scoreEl.innerText = `SCORE: ${score}`;
            showJudgement("PERFECT", "#0ff");
            
            // 新增特效
            hitEffects.push({
                x: startX + lane * laneWidth + laneWidth/2,
                y: judgeY,
                r: 20,
                life: 1.0,
                color: COLORS[lane]
            });
        }
    }
}

function resetCombo() {
    combo = 0;
    comboEl.innerText = "";
    showJudgement("MISS", "#ff3333");
}

function showJudgement(text, color) {
    judgeEl.innerText = text;
    judgeEl.style.color = color;
    judgeEl.style.opacity = 1;
    judgeEl.style.transform = "scale(1.2)";
    // 簡單的動畫重置
    setTimeout(() => {
        judgeEl.style.transform = "scale(1)";
    }, 50);
}

function formatTime(seconds) {
    const m = Math.floor(seconds / 60);
    const s = Math.floor(seconds % 60);
    return `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
}

// 事件監聽
LANE_KEYS.forEach((key, i) => {
    const btn = document.getElementById(`btn-${i}`);
    // 觸控
    btn.addEventListener('touchstart', (e) => { e.preventDefault(); handleInput(i, true); });
    btn.addEventListener('touchend', (e) => { e.preventDefault(); handleInput(i, false); });
});

// 鍵盤
window.addEventListener('keydown', (e) => {
    if (e.repeat) return;
    const idx = LANE_KEYS.indexOf(e.key.toLowerCase());
    if (idx !== -1) handleInput(idx, true);
});
window.addEventListener('keyup', (e) => {
    const idx = LANE_KEYS.indexOf(e.key.toLowerCase());
    if (idx !== -1) handleInput(idx, false);
});
</script>
</body>
</html>
