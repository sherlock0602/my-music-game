<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Neon Beat - Auto Sync</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;900&display=swap');

        /* 基礎設定 */
        * { -webkit-tap-highlight-color: transparent; -webkit-touch-callout: none; user-select: none; touch-action: none; box-sizing: border-box; outline: none; }
        body { margin: 0; background: #050505; color: white; overflow: hidden; font-family: 'Orbitron', sans-serif; width: 100vw; height: 100vh; position: fixed; }

        /* 背景與網格 */
        #bg { position: absolute; inset: 0; z-index: 0; background: radial-gradient(circle at 50% 100%, #1a1a2e, #000); }
        #grid {
            position: absolute; inset: 0; z-index: 1; opacity: 0.3;
            background-image: linear-gradient(rgba(0, 255, 255, 0.1) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(0, 255, 255, 0.1) 1px, transparent 1px);
            background-size: 50px 50px;
            transform: perspective(600px) rotateX(60deg);
            transform-origin: center bottom;
        }

        /* 讀取畫面 */
        #loader-layer { 
            position: absolute; inset: 0; z-index: 100; background: rgba(0,0,0,0.95);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.5s;
        }
        h1 { font-size: 40px; color: #fff; text-shadow: 0 0 20px #0ff; margin-bottom: 20px; text-align: center; }
        
        #status-text { color: #0ff; font-size: 14px; margin-bottom: 30px; letter-spacing: 1px; animation: blink 1.5s infinite; }
        @keyframes blink { 50% { opacity: 0.5; } }

        #start-btn {
            padding: 15px 50px; font-size: 24px; font-weight: 900; color: #000; background: #0ff;
            border: none; border-radius: 5px; cursor: pointer; font-family: 'Orbitron';
            box-shadow: 0 0 30px #0ff; display: none; /* 預設隱藏，分析完才顯示 */
        }
        #start-btn:active { transform: scale(0.95); }

        /* 遊戲介面 */
        #ui-layer { position: absolute; top: 0; width: 100%; z-index: 10; pointer-events: none; text-align: center; margin-top: 40px; }
        #combo-num { font-size: 70px; font-weight: 900; margin: 0; text-shadow: 0 0 20px rgba(0,255,255,0.8); }
        #score-text { font-size: 16px; color: #aaa; letter-spacing: 2px; }
        #judgement { font-size: 28px; font-weight: bold; height: 30px; margin-top: 10px; opacity: 0; transition: 0.1s; }

        /* 遊戲區域 */
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 5; }

        /* 按鍵區 */
        #controls { 
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 8px; z-index: 20;
        }
        .key-btn {
            height: 110px; 
            background: rgba(255,255,255,0.05); border: 2px solid rgba(255,255,255,0.1); border-radius: 12px;
            display: flex; align-items: flex-end; justify-content: center; padding-bottom: 15px;
            font-size: 24px; color: rgba(255,255,255,0.4); font-weight: bold; backdrop-filter: blur(4px);
        }
        .key-btn.active { background: #0ff; color: #000; box-shadow: 0 0 25px #0ff; transform: scale(0.96); border-color: #fff; }

        /* 進度條 */
        #progress-container { position: absolute; top: 0; left: 0; width: 100%; height: 4px; background: #222; z-index: 50; }
        #progress-bar { width: 0%; height: 100%; background: #0ff; box-shadow: 0 0 10px #0ff; transition: width 0.1s linear; }
    </style>
</head>
<body>

    <div id="bg"></div>
    <div id="grid"></div>
    <div id="progress-container"><div id="progress-bar"></div></div>

    <div id="loader-layer">
        <h1>NEON BEAT</h1>
        <div id="status-text">正在下載音樂檔案...</div>
        <button id="start-btn" onclick="startGame()">START GAME</button>
    </div>

    <div id="ui-layer">
        <p id="score-text">SCORE: 0</p>
        <p id="combo-num">0</p>
        <div id="judgement">READY</div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="controls">
        <div class="key-btn" id="btn-0">D</div>
        <div class="key-btn" id="btn-1">F</div>
        <div class="key-btn" id="btn-2">J</div>
        <div class="key-btn" id="btn-3">K</div>
    </div>

<script>
// --- 設定區 ---
const MUSIC_URL = 'music.mp3'; // 固定讀取這個檔名
const OFFSET = 0;              // 預設延遲修正 (毫秒)
const NOTE_SPEED = 0.85;       // 音符下落速度
const LEAD_TIME = 1500;        // 音符提前生成時間
const COLORS = ['#FF0055', '#00FBFF', '#BCFF00', '#FF9500'];

// --- 變數宣告 ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const comboEl = document.getElementById('combo-num');
const scoreEl = document.getElementById('score-text');
const judgeEl = document.getElementById('judgement');
const progressEl = document.getElementById('progress-bar');
const statusText = document.getElementById('status-text');
const startBtn = document.getElementById('start-btn');
const loaderLayer = document.getElementById('loader-layer');

let laneWidth, startX, judgeY;
let audioCtx, audioBuffer, audioSource;
let isPlaying = false, startTime = 0;
let generatedNotes = [], activeNotes = [];
let combo = 0, score = 0;
let activeKeys = [false, false, false, false];

// --- 1. 初始化與讀取 ---
window.onload = async function() {
    resize();
    window.addEventListener('resize', resize);

    try {
        // 自動讀取同目錄下的 music.mp3
        const response = await fetch(MUSIC_URL);
        if (!response.ok) throw new Error("找不到檔案");
        
        const arrayBuffer = await response.arrayBuffer();
        
        statusText.innerText = "正在分析節拍頻譜...";
        
        // 建立 AudioContext (暫時不播放)
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        // 解碼並分析
        audioCtx.decodeAudioData(arrayBuffer, (buffer) => {
            audioBuffer = buffer;
            analyzeBeats(buffer); // 執行分析演算法
        }, (e) => {
            throw new Error("解碼失敗，請確認是 MP3 格式");
        });

    } catch (err) {
        statusText.style.color = "#ff4d4d";
        statusText.innerText = "錯誤：請確認目錄下有 music.mp3 檔案";
        console.error(err);
    }
};

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    laneWidth = Math.min(90, canvas.width / 4.5);
    startX = (canvas.width - laneWidth * 4) / 2;
    judgeY = canvas.height * 0.8;
    
    // 更新按鈕 CSS
    const controls = document.getElementById('controls');
    controls.style.width = (laneWidth * 4) + 'px';
    document.querySelectorAll('.key-btn').forEach(b => b.style.width = (laneWidth - 8) + 'px');
}

// --- 2. 節拍分析演算法 (自動生成譜面) ---
function analyzeBeats(buffer) {
    const rawData = buffer.getChannelData(0); // 讀取左聲道
    const sampleRate = buffer.sampleRate;
    const step = Math.floor(sampleRate / 50); // 每秒採樣 50 次 (足夠精確且不卡頓)
    
    generatedNotes = [];
    
    // 計算整首歌的平均音量，用來決定門檻
    let sum = 0, count = 0;
    for (let i = 0; i < rawData.length; i += step) {
        sum += Math.abs(rawData[i]);
        count++;
    }
    const average = sum / count;
    const threshold = average * 1.8; // 門檻：必須大於平均音量的 1.8 倍

    let lastIndex = -10000;
    const minDistance = sampleRate * 0.35; // 兩個音符最短間隔 0.35 秒

    for (let i = 0; i < rawData.length; i += step) {
        const energy = Math.abs(rawData[i]);
        
        // 如果能量超過門檻 且 距離上次夠遠
        if (energy > threshold && (i - lastIndex) > minDistance) {
            const timeMs = (i / sampleRate) * 1000;
            
            // 簡單的軌道分配邏輯 (隨機但盡量不重複)
            let lane = Math.floor(Math.random() * 4);
            
            generatedNotes.push({
                time: timeMs,
                lane: lane,
                hit: false
            });
            lastIndex = i;
        }
    }

    statusText.innerText = `分析完成！偵測到 ${generatedNotes.length} 個節拍`;
    statusText.style.animation = "none";
    statusText.style.color = "#fff";
    startBtn.style.display = "block"; // 顯示開始按鈕
}

// --- 3. 遊戲核心 ---
function startGame() {
    if(!audioBuffer) return;
    loaderLayer.style.opacity = 0;
    setTimeout(() => loaderLayer.style.display = 'none', 500);

    // 複製譜面
    activeNotes = JSON.parse(JSON.stringify(generatedNotes));
    
    // 播放音樂
    audioSource = audioCtx.createBufferSource();
    audioSource.buffer = audioBuffer;
    audioSource.connect(audioCtx.destination);
    
    // 同步啟動
    startTime = audioCtx.currentTime * 1000 + LEAD_TIME;
    audioSource.start(audioCtx.currentTime + (LEAD_TIME / 1000));
    
    isPlaying = true;
    requestAnimationFrame(gameLoop);
}

function gameLoop() {
    if(!isPlaying) return;
    const now = (audioCtx.currentTime * 1000) - startTime + LEAD_TIME;

    // 更新進度條
    if(audioBuffer) {
        const pct = (now / (audioBuffer.duration * 1000)) * 100;
        progressEl.style.width = Math.min(100, pct) + "%";
        if(pct > 100) isPlaying = false; // 結束
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 繪製軌道
    for(let i=0; i<4; i++) {
        const x = startX + i * laneWidth;
        
        // 判定線
        ctx.strokeStyle = activeKeys[i] ? '#fff' : 'rgba(255,255,255,0.2)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(x + 5, judgeY);
        ctx.lineTo(x + laneWidth - 5, judgeY);
        ctx.stroke();

        // 軌道光束
        if(activeKeys[i]) {
            const g = ctx.createLinearGradient(0, judgeY, 0, 0);
            g.addColorStop(0, COLORS[i]);
            g.addColorStop(1, 'transparent');
            ctx.fillStyle = g;
            ctx.globalAlpha = 0.4;
            ctx.fillRect(x + 5, 0, laneWidth - 10, judgeY);
            ctx.globalAlpha = 1;
        }
    }

    // 繪製音符
    activeNotes.forEach(n => {
        if(n.hit) return;
        const diff = (n.time + OFFSET) - now;

        // MISS 判定
        if(diff < -200) {
            n.hit = true;
            combo = 0; comboEl.innerText = 0;
            judgeEl.innerText = "MISS"; judgeEl.style.color = "#555";
            return;
        }

        const y = judgeY - (diff * NOTE_SPEED);
        
        if(y < canvas.height && y > -50) {
            const x = startX + n.lane * laneWidth;
            ctx.fillStyle = COLORS[n.lane];
            ctx.shadowBlur = 15; ctx.shadowColor = COLORS[n.lane];
            
            ctx.beginPath();
            ctx.roundRect(x + 8, y - 10, laneWidth - 16, 20, 4);
            ctx.fill();
            ctx.shadowBlur = 0;
        }
    });

    requestAnimationFrame(gameLoop);
}

// --- 4. 輸入判定 ---
function handleInput(lane, isDown) {
    if(lane < 0 || lane >= 4) return;
    activeKeys[lane] = isDown;
    const btn = document.getElementById(`btn-${lane}`);
    if(btn) btn.classList.toggle('active', isDown);

    if(isDown && isPlaying) {
        const now = (audioCtx.currentTime * 1000) - startTime + LEAD_TIME;
        
        // 尋找最近的音符 (判定區間 160ms)
        const note = activeNotes.find(n => !n.hit && n.lane === lane && Math.abs((n.time + OFFSET) - now) < 160);
        
        if(note) {
            note.hit = true;
            combo++; score += 100 + combo * 10;
            comboEl.innerText = combo;
            scoreEl.innerText = `SCORE: ${score}`;
            
            // 判定準度
            const err = Math.abs((note.time + OFFSET) - now);
            if(err < 60) {
                judgeEl.innerText = "PERFECT"; judgeEl.style.color = "#0ff";
            } else {
                judgeEl.innerText = "GOOD"; judgeEl.style.color = "#ff0";
            }
            
            // 判定字樣動畫
            judgeEl.style.opacity = 1;
            judgeEl.style.transform = "scale(1.2)";
            setTimeout(() => { judgeEl.style.transform = "scale(1)"; judgeEl.style.opacity = 0; }, 200);
        }
    }
}

// 綁定事件
['d','f','j','k'].forEach((k, i) => {
    const el = document.getElementById(`btn-${i}`);
    el.addEventListener('touchstart', (e)=>{ e.preventDefault(); handleInput(i, true); });
    el.addEventListener('touchend', (e)=>{ e.preventDefault(); handleInput(i, false); });
});
window.addEventListener('keydown', e => {
    const i = ['d','f','j','k'].indexOf(e.key.toLowerCase());
    if(i > -1 && !activeKeys[i]) handleInput(i, true);
});
window.addEventListener('keyup', e => {
    const i = ['d','f','j','k'].indexOf(e.key.toLowerCase());
    if(i > -1) handleInput(i, false);
});
</script>
</body>
</html>
