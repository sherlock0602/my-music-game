<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Neon Beat - Ultimate Sync</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;900&display=swap');

        /* --- 核心防錯與基礎設定 --- */
        * { 
            -webkit-tap-highlight-color: transparent; 
            -webkit-touch-callout: none; 
            -webkit-user-select: none; 
            user-select: none; 
            outline: none; 
            box-sizing: border-box;
            touch-action: none; /* 禁止縮放 */
        }
        body { margin: 0; background: #000; color: white; overflow: hidden; font-family: 'Orbitron', sans-serif; position: fixed; width: 100%; height: 100%; }

        /* --- 背景特效 (保留酷炫版) --- */
        #bg-grid {
            position: absolute; inset: 0;
            background-image: linear-gradient(rgba(0, 255, 255, 0.05) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(0, 255, 255, 0.05) 1px, transparent 1px);
            background-size: 50px 50px;
            transform: perspective(500px) rotateX(60deg);
            transform-origin: center bottom;
            z-index: 0;
            animation: grid-move 2s linear infinite;
        }
        @keyframes grid-move { from { background-position: 0 0; } to { background-position: 0 50px; } }

        /* --- UI 介面 --- */
        #ui { position: absolute; top: 40px; width: 100%; text-align: center; pointer-events: none; z-index: 10; }
        #score-display { font-size: 14px; letter-spacing: 3px; color: #0ff; margin: 0; text-shadow: 0 0 5px #0ff; }
        #combo { font-size: 80px; font-weight: 900; margin: 0; text-shadow: 0 0 20px #0ff, 0 0 40px #0ff; }
        #judgement { height: 40px; font-weight: 900; font-size: 28px; letter-spacing: 2px; margin-top: 5px; opacity: 0; transition: transform 0.1s; }

        /* --- 右上角計時器 --- */
        #timer-container {
            position: absolute; top: 20px; right: 20px; width: 150px; text-align: right; z-index: 15;
        }
        #time-text { font-size: 18px; color: #0ff; font-weight: bold; margin-bottom: 5px; }
        #progress-bar { width: 100%; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; overflow: hidden; }
        #progress-fill { width: 0%; height: 100%; background: #0ff; box-shadow: 0 0 10px #0ff; }

        /* --- 載入與開始畫面 --- */
        .overlay { position: absolute; inset: 0; background: radial-gradient(circle, #001f3f 0%, #000 100%); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; transition: opacity 0.5s; }
        
        #status-text { color: #0ff; margin-bottom: 20px; font-size: 14px; letter-spacing: 1px; animation: pulse 1.5s infinite; }
        @keyframes pulse { 50% { opacity: 0.5; } }

        .start-btn { 
            padding: 15px 50px; font-size: 20px; cursor: pointer; background: transparent; 
            color: #0ff; border: 2px solid #0ff; font-family: 'Orbitron'; font-weight: 900;
            box-shadow: 0 0 15px rgba(0,255,255,0.3); transition: 0.2s;
            display: none; /* 分析完才顯示 */
        }
        .start-btn:active { background: #0ff; color: #000; transform: scale(0.95); }

        /* --- 遊戲按鈕 (大按鈕、平板優化) --- */
        #touch-controls { 
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; justify-content: center; gap: 10px; z-index: 20;
        }
        .touch-btn {
            height: 110px; /* 大尺寸 */
            border: 2px solid rgba(0, 255, 255, 0.3); border-radius: 15px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: rgba(0, 40, 40, 0.6); backdrop-filter: blur(10px); transition: 0.05s;
        }
        .touch-btn span { font-size: 32px; font-weight: 900; color: #fff; pointer-events: none; }
        .touch-btn small { font-size: 10px; color: #0ff; margin-top: 5px; pointer-events: none; }
        
        .touch-btn.active { background: #0ff; border-color: #fff; box-shadow: 0 0 30px #0ff; transform: translateY(5px) scale(0.95); }
        .touch-btn.active span { color: #000; }
        .touch-btn.active small { color: #000; }

        canvas { display: block; filter: contrast(1.1); }
    </style>
</head>
<body>

    <div id="bg-grid"></div>

    <div id="loader-layer" class="overlay">
        <h1 style="font-size: 50px; text-shadow: 0 0 20px #0ff; margin-bottom: 10px;">NEON BEAT</h1>
        <div id="status-text">SYSTEM INITIALIZING...</div>
        <button id="start-btn" class="start-btn" onclick="startGame()">START MISSION</button>
        <p style="color: #444; font-size: 12px; margin-top: 30px;">Reading: music.mp3</p>
    </div>

    <div id="timer-container">
        <div id="time-text">00:00</div>
        <div id="progress-bar"><div id="progress-fill"></div></div>
    </div>

    <div id="ui">
        <p id="score-display">SYNC RATE: 0%</p>
        <p id="combo">0</p>
        <div id="judgement">READY</div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="touch-controls">
        <div class="touch-btn" id="btn-0"><span>D</span><small>L1</small></div>
        <div class="touch-btn" id="btn-1"><span>F</span><small>L2</small></div>
        <div class="touch-btn" id="btn-2"><span>J</span><small>R1</small></div>
        <div class="touch-btn" id="btn-3"><span>K</span><small>R2</small></div>
    </div>

<script>
// --- 設定區 ---
const MUSIC_URL = 'music.mp3'; 
const NOTE_SPEED = 0.8;       
const LEAD_TIME = 1500;        
const COLORS = ['#FF0055', '#00FBFF', '#BCFF00', '#FF9500'];
const LANE_KEYS = ['d', 'f', 'j', 'k'];

// --- 系統變數 ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const comboEl = document.getElementById('combo');
const scoreEl = document.getElementById('score-display');
const judgeEl = document.getElementById('judgement');
const timeText = document.getElementById('time-text');
const progFill = document.getElementById('progress-fill');
const statusText = document.getElementById('status-text');
const startBtn = document.getElementById('start-btn');
const loaderLayer = document.getElementById('loader-layer');

let laneWidth, startX, judgeY;
let audioCtx, audioBuffer, audioSource;
let isPlaying = false, startTime = 0;
let generatedNotes = [], activeNotes = [];
let combo = 0, score = 0, maxScore = 0;
let activeKeys = [false, false, false, false];

// --- 1. 啟動與分析 (Auto Run) ---
window.onload = async function() {
    resize();
    window.addEventListener('resize', resize);
    
    try {
        statusText.innerText = "DOWNLOADING MUSIC...";
        const response = await fetch(MUSIC_URL);
        if (!response.ok) throw new Error("File not found");
        
        const arrayBuffer = await response.arrayBuffer();
        statusText.innerText = "ANALYZING BEATS...";
        
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        audioCtx.decodeAudioData(arrayBuffer, (buffer) => {
            audioBuffer = buffer;
            analyzeBeats(buffer);
        }, () => { throw new Error("Decode Error"); });

    } catch (err) {
        statusText.style.color = "#ff3333";
        statusText.innerText = "ERROR: music.mp3 NOT FOUND";
        console.error(err);
    }
};

// --- 2. 頻譜分析算法 (生成譜面) ---
function analyzeBeats(buffer) {
    const rawData = buffer.getChannelData(0);
    const sampleRate = buffer.sampleRate;
    const step = Math.floor(sampleRate / 60); // 降低採樣率以提升效能
    
    generatedNotes = [];
    
    // 計算平均音量
    let sum = 0, count = 0;
    for (let i = 0; i < rawData.length; i += step) {
        sum += Math.abs(rawData[i]);
        count++;
    }
    const threshold = (sum / count) * 1.6; // 門檻係數

    let lastIndex = -10000;
    const minDistance = sampleRate * 0.35; // 最小間隔

    for (let i = 0; i < rawData.length; i += step) {
        if (Math.abs(rawData[i]) > threshold && (i - lastIndex) > minDistance) {
            const timeMs = (i / sampleRate) * 1000;
            generatedNotes.push({
                time: timeMs,
                lane: Math.floor(Math.random() * 4),
                hit: false
            });
            lastIndex = i;
        }
    }

    maxScore = generatedNotes.length * 100; // 預估滿分
    statusText.innerText = `ANALYSIS COMPLETE: ${generatedNotes.length} BEATS`;
    statusText.style.animation = "none";
    statusText.style.color = "#fff";
    startBtn.style.display = "block";
}

// --- 3. 畫面適配 ---
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    // 平板優化寬度
    laneWidth = Math.min(110, canvas.width / 4.2); 
    startX = (canvas.width - laneWidth * 4) / 2;
    judgeY = canvas.height * 0.75; // 判定線位置

    // 同步按鈕寬度
    const controls = document.getElementById('touch-controls');
    controls.style.width = (laneWidth * 4) + 'px';
    document.querySelectorAll('.touch-btn').forEach(b => {
        b.style.width = (laneWidth - 10) + 'px';
    });
}

// --- 4. 遊戲核心 ---
function startGame() {
    if(!audioBuffer) return;
    loaderLayer.style.opacity = 0;
    setTimeout(() => loaderLayer.style.display = 'none', 500);

    activeNotes = JSON.parse(JSON.stringify(generatedNotes));
    
    audioSource = audioCtx.createBufferSource();
    audioSource.buffer = audioBuffer;
    audioSource.connect(audioCtx.destination);
    
    startTime = audioCtx.currentTime * 1000 + LEAD_TIME;
    audioSource.start(audioCtx.currentTime + (LEAD_TIME / 1000));
    
    isPlaying = true;
    requestAnimationFrame(gameLoop);
}

function gameLoop() {
    if(!isPlaying) return;
    const now = (audioCtx.currentTime * 1000) - startTime + LEAD_TIME;

    // 更新 UI 計時器
    if(audioBuffer) {
        const total = audioBuffer.duration;
        const current = Math.max(0, (now - LEAD_TIME) / 1000); // 修正顯示時間
        const pct = (current / total) * 100;
        
        progFill.style.width = Math.min(100, pct) + "%";
        
        const m = Math.floor(current / 60);
        const s = Math.floor(current % 60);
        timeText.innerText = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;

        if(current > total) isPlaying = false;
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 繪製軌道
    for(let i=0; i<4; i++) {
        const x = startX + i * laneWidth;
        
        // 判定線光效
        ctx.strokeStyle = activeKeys[i] ? '#fff' : 'rgba(255,255,255,0.2)';
        ctx.lineWidth = activeKeys[i] ? 4 : 2;
        ctx.strokeRect(x + 5, judgeY, laneWidth - 10, 4);

        // 按下時的光柱
        if(activeKeys[i]) {
            const g = ctx.createLinearGradient(0, judgeY, 0, 0);
            g.addColorStop(0, COLORS[i] + '66'); // 半透明
            g.addColorStop(1, 'transparent');
            ctx.fillStyle = g;
            ctx.fillRect(x + 5, 0, laneWidth - 10, judgeY);
        }
    }

    // 繪製音符
    activeNotes.forEach(n => {
        if(n.hit) return;
        const diff = n.time - now;

        // MISS 判定 (超過 200ms)
        if(diff < -200) {
            n.hit = true;
            combo = 0; comboEl.innerText = 0;
            showJudge("MISS", "#555");
            return;
        }

        const y = judgeY - (diff * NOTE_SPEED);
        
        if(y < canvas.height && y > -50) {
            const x = startX + n.lane * laneWidth;
            
            // 霓虹音符
            ctx.fillStyle = COLORS[n.lane];
            ctx.shadowBlur = 15; ctx.shadowColor = COLORS[n.lane];
            ctx.beginPath();
            ctx.roundRect(x + 8, y - 12, laneWidth - 16, 24, 6);
            ctx.fill();
            ctx.shadowBlur = 0;
        }
    });

    requestAnimationFrame(gameLoop);
}

// --- 5. 輸入判定 ---
function handleInput(lane, isDown) {
    if(lane < 0 || lane >= 4) return;
    activeKeys[lane] = isDown;
    const btn = document.getElementById(`btn-${lane}`);
    if(btn) btn.classList.toggle('active', isDown);

    if(isDown && isPlaying) {
        const now = (audioCtx.currentTime * 1000) - startTime + LEAD_TIME;
        
        // 尋找判定區 (前後 150ms)
        const note = activeNotes.find(n => !n.hit && n.lane === lane && Math.abs(n.time - now) < 150);
        
        if(note) {
            note.hit = true;
            combo++;
            score += 100;
            
            comboEl.innerText = combo;
            scoreEl.innerText = `SCORE: ${score}`;
            
            const diff = Math.abs(note.time - now);
            if(diff < 50) showJudge("PERFECT", "#0ff");
            else showJudge("GOOD", "#ff0");
        }
    }
}

function showJudge(text, color) {
    judgeEl.innerText = text;
    judgeEl.style.color = color;
    judgeEl.style.textShadow = `0 0 15px ${color}`;
    judgeEl.style.opacity = 1;
    judgeEl.style.transform = "scale(1.2)";
    
    // 重置動畫
    clearTimeout(judgeEl.timer);
    judgeEl.timer = setTimeout(() => {
        judgeEl.style.opacity = 0;
        judgeEl.style.transform = "scale(1)";
    }, 200);
}

// 綁定事件
LANE_KEYS.forEach((k, i) => {
    const el = document.getElementById(`btn-${i}`);
    el.addEventListener('touchstart', (e)=>{ e.preventDefault(); handleInput(i, true); });
    el.addEventListener('touchend', (e)=>{ e.preventDefault(); handleInput(i, false); });
});
window.addEventListener('keydown', e => {
    const i = LANE_KEYS.indexOf(e.key.toLowerCase());
    if(i > -1 && !activeKeys[i]) handleInput(i, true);
});
window.addEventListener('keyup', e => {
    const i = LANE_KEYS.indexOf(e.key.toLowerCase());
    if(i > -1) handleInput(i, false);
});
</script>
</body>
</html>
