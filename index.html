<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Neon Beat - Pro Sync</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        * { -webkit-tap-highlight-color: transparent; -webkit-touch-callout: none; user-select: none; touch-action: none; box-sizing: border-box; outline: none; }
        body { 
            margin: 0; background: #000; color: #fff; overflow: hidden; 
            font-family: 'Orbitron', sans-serif; 
            width: 100vw; height: 100vh;
            display: flex; justify-content: center;
        }

        #game-container {
            position: relative; width: 100%; max-width: 800px; height: 100%;
            background: linear-gradient(to bottom, #050510 0%, #101020 100%);
            overflow: hidden; box-shadow: 0 0 100px rgba(0,0,0,1);
        }

        /* --- UI 層 --- */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        .hud-top {
            display: flex; justify-content: space-between; padding: 20px;
            text-shadow: 0 0 10px #0ff;
        }
        .hud-val { font-size: 24px; font-weight: 700; color: #fff; }
        .hud-lbl { font-size: 10px; color: #0ff; opacity: 0.7; letter-spacing: 1px; }

        #center-hud { position: absolute; top: 18%; width: 100%; text-align: center; }
        #combo-num { 
            font-size: 90px; font-weight: 900; margin: 0; color: #fff; 
            text-shadow: 0 0 30px rgba(0,255,255,0.5); font-style: italic;
            transform: scale(1); transition: transform 0.05s;
        }
        #judgement { 
            font-size: 36px; font-weight: 900; letter-spacing: 3px; opacity: 0; 
            text-shadow: 0 0 20px currentColor; margin-top: 5px;
        }

        /* --- 校準滑桿 (關鍵新功能) --- */
        #offset-controls {
            position: absolute; bottom: 35%; width: 100%; text-align: center; pointer-events: auto; z-index: 50;
            display: flex; flex-direction: column; align-items: center; opacity: 0.8;
        }
        #offset-label { font-size: 12px; color: #aaa; margin-bottom: 5px; text-shadow: 0 0 5px #000; }
        input[type=range] {
            width: 60%; accent-color: #0ff; cursor: pointer; height: 5px;
        }

        /* --- 載入層 --- */
        #loader {
            position: absolute; inset: 0; z-index: 100; background: #000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        #status-text { margin-top: 20px; color: #0ff; font-size: 12px; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0.5; } }
        
        #start-btn {
            margin-top: 30px; padding: 15px 50px; font-size: 20px;
            background: #0ff; color: #000; border: none; font-weight: 900;
            box-shadow: 0 0 30px #0ff; cursor: pointer; display: none;
            clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
        }

        /* --- 觸控層 --- */
        #touch-layer {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 25%;
            z-index: 20; display: flex;
        }
        .touch-zone { flex: 1; height: 100%; /* border: 1px dashed rgba(255,255,255,0.1); */ }

        canvas { display: block; position: absolute; inset: 0; z-index: 5; }
    </style>
</head>
<body>

<div id="game-container">
    <div id="loader">
        <h1 style="font-size: 40px; text-shadow: 0 0 30px #0ff;">NEON SYNC</h1>
        <div id="status-text">INITIALIZING AUDIO ENGINE...</div>
        <button id="start-btn" onclick="startGame()">START SYSTEM</button>
    </div>

    <div id="ui-layer">
        <div class="hud-top">
            <div><div class="hud-lbl">TIME</div><div class="hud-val" id="timer">00:00</div></div>
            <div style="text-align: right;"><div class="hud-lbl">SCORE</div><div class="hud-val" id="score">000000</div></div>
        </div>
        <div id="center-hud">
            <div id="combo-num">0</div>
            <div id="judgement">PERFECT</div>
        </div>
    </div>

    <div id="offset-controls">
        <div id="offset-label">LAG FIX: 0ms (Drag if off-sync)</div>
        <input type="range" id="offset-slider" min="-300" max="300" step="10" value="0">
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="touch-layer">
        <div class="touch-zone" id="z0"></div>
        <div class="touch-zone" id="z1"></div>
        <div class="touch-zone" id="z2"></div>
        <div class="touch-zone" id="z3"></div>
    </div>
</div>

<script>
// --- 設定區 ---
const MUSIC_URL = 'music.mp3';
const LEAD_TIME = 1300; // 音符飛行時間 (固定)
const LANE_COLORS = ['#FFD700', '#00BFFF', '#00FF88', '#BD00FF']; // 黃, 藍, 綠, 紫
const LANE_KEYS = ['D', 'F', 'J', 'K'];

// --- 系統變數 ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let userOffset = 0; // 用戶手動校準值

// 3D 軌道參數
const HIT_Y = 0.75; // 判定線位置
const VANISH_Y = 0.25; // 消失點
const BTN_Y = 0.92; // 按鈕位置

let audioCtx, audioBuffer, audioSource;
let isPlaying = false, startTime = 0;
let generatedNotes = [], activeNotes = [];
let combo = 0, score = 0;
let activeKeys = [false, false, false, false];
let particles = [], stars = [];

// --- 初始化 ---
window.onload = async function() {
    resize();
    window.addEventListener('resize', resize);
    initStars();

    // 綁定滑桿事件
    const slider = document.getElementById('offset-slider');
    const label = document.getElementById('offset-label');
    slider.addEventListener('input', (e) => {
        userOffset = parseInt(e.target.value);
        label.innerText = `LAG FIX: ${userOffset > 0 ? '+' : ''}${userOffset}ms`;
    });

    try {
        const response = await fetch(MUSIC_URL);
        const arrayBuffer = await response.arrayBuffer();
        document.getElementById('status-text').innerText = "ANALYZING BASS FREQUENCIES...";
        
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        audioCtx.decodeAudioData(arrayBuffer, (buffer) => {
            audioBuffer = buffer;
            analyzeBeats(buffer); // 使用新的分析算法
        });
    } catch (err) {
        document.getElementById('status-text').innerText = "ERROR: music.mp3 NOT FOUND";
        document.getElementById('status-text').style.color = "red";
    }
};

function resize() {
    const rect = document.getElementById('game-container').getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
}

// --- 新版節拍分析 (動態門檻 + 低通濾波模擬) ---
function analyzeBeats(buffer) {
    const rawData = buffer.getChannelData(0);
    const sampleRate = buffer.sampleRate;
    
    // 為了效能，我們把採樣率降低 (Downsampling)
    // 我們只關心低頻能量，這可以通過簡單的移動平均來模擬低通濾波
    const step = Math.floor(sampleRate / 100); // 10ms 一個採樣點
    const winSize = step * 5; // 窗口大小
    
    generatedNotes = [];
    let localEnergies = [];
    
    // 1. 計算能量圖譜
    for (let i = 0; i < rawData.length; i += step) {
        let sum = 0;
        // 取一小段計算 RMS (Root Mean Square) 能量
        for (let j = 0; j < winSize && (i+j) < rawData.length; j++) {
            sum += rawData[i+j] * rawData[i+j];
        }
        localEnergies.push(Math.sqrt(sum / winSize));
    }

    // 2. 動態門檻偵測
    // 我們比較「當前能量」與「周圍 1 秒的平均能量」
    const historySize = 40; // 比較過去 0.4 秒
    let history = new Array(historySize).fill(0);
    let lastBeatTime = -1000;

    for (let i = 0; i < localEnergies.length; i++) {
        const energy = localEnergies[i];
        
        // 計算局部平均
        const localAvg = history.reduce((a,b)=>a+b) / historySize;
        
        // 核心算法：能量必須大於局部平均的 C 倍 (C 是常數，這裡設 1.4)
        // 且能量本身不能太小 (去除噪音)
        if (energy > localAvg * 1.4 && energy > 0.1) {
            const timeMs = i * 10; // 每個點代表 10ms
            
            // 防止機關槍：兩個音符至少間隔 200ms
            if (timeMs - lastBeatTime > 250) {
                generatedNotes.push({
                    time: timeMs,
                    lane: Math.floor(Math.random() * 4), // 隨機軌道
                    hit: false
                });
                lastBeatTime = timeMs;
            }
        }
        
        history.shift();
        history.push(energy);
    }

    document.getElementById('status-text').innerText = `SYNCED: ${generatedNotes.length} BEATS DETECTED`;
    document.getElementById('status-text').style.animation = 'none';
    document.getElementById('status-text').style.color = '#fff';
    document.getElementById('start-btn').style.display = 'block';
}

function startGame() {
    document.getElementById('loader').style.display = 'none';
    activeNotes = JSON.parse(JSON.stringify(generatedNotes));
    
    audioSource = audioCtx.createBufferSource();
    audioSource.buffer = audioBuffer;
    audioSource.connect(audioCtx.destination);
    
    startTime = audioCtx.currentTime * 1000 + LEAD_TIME;
    audioSource.start(audioCtx.currentTime + (LEAD_TIME / 1000));
    
    isPlaying = true;
    requestAnimationFrame(gameLoop);
}

// --- 3D 繪圖核心 ---
function getCoords(lane, progress) {
    // progress 0 = 消失點, 1 = 判定線
    const yStart = canvas.height * VANISH_Y;
    const yHit = canvas.height * HIT_Y;
    const h = yHit - yStart;

    // 計算 Y
    let y;
    if (progress <= 1) {
        y = yStart + (h * progress);
    } else {
        // 延伸到底部
        const yBot = canvas.height * BTN_Y;
        y = yHit + (yBot - yHit) * (progress - 1) * 3; // 加速延伸
    }

    // 計算寬度 (透視)
    const wTop = canvas.width * 0.1;
    const wHit = canvas.width * 0.85;
    
    let totalW;
    if (progress <= 1) {
        totalW = wTop + (wHit - wTop) * progress;
    } else {
        const wBot = canvas.width * 1.1;
        totalW = wHit + (wBot - wHit) * (progress - 1) * 3;
    }

    const laneW = totalW / 4;
    const xStart = (canvas.width - totalW) / 2;
    const x = xStart + lane * laneW;

    return { x, y, w: laneW };
}

function gameLoop() {
    if(!isPlaying) return;
    const now = (audioCtx.currentTime * 1000) - startTime + LEAD_TIME;

    // UI Update
    if(audioBuffer) {
        let rem = Math.max(0, audioBuffer.duration - (audioCtx.currentTime - (startTime/1000) + (LEAD_TIME/1000)));
        if (rem === 0) isPlaying = false;
        const m = Math.floor(rem/60).toString().padStart(2,'0');
        const s = Math.floor(rem%60).toString().padStart(2,'0');
        document.getElementById('timer').innerText = `${m}:${s}`;
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 1. 星空
    drawStars();

    // 2. 軌道線
    ctx.lineWidth = 1;
    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    for(let i=0; i<=4; i++) {
        const p1 = getCoords(i, 0);
        const p2 = getCoords(i, 1.1);
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
    }

    // 3. 實體按鈕 (在判定線後方)
    for(let i=0; i<4; i++) {
        const pTop = getCoords(i, 1.0);
        const pBot = getCoords(i, 1.1);
        const color = LANE_COLORS[i];

        ctx.beginPath();
        ctx.moveTo(pTop.x, pTop.y);
        ctx.lineTo(pTop.x + pTop.w, pTop.y);
        ctx.lineTo(pBot.x + pBot.w, pBot.y);
        ctx.lineTo(pBot.x, pBot.y);
        ctx.closePath();

        if (activeKeys[i]) {
            // 按下特效
            ctx.fillStyle = color;
            ctx.globalAlpha = 0.6;
            ctx.fill();
            // 光柱
            const pFar = getCoords(i, 0);
            const g = ctx.createLinearGradient(0, pTop.y, 0, pFar.y);
            g.addColorStop(0, color); g.addColorStop(1, 'transparent');
            ctx.fillStyle = g; ctx.globalAlpha = 0.3;
            ctx.beginPath();
            ctx.moveTo(pTop.x, pTop.y); ctx.lineTo(pTop.x+pTop.w, pTop.y);
            ctx.lineTo(pFar.x+pFar.w, pFar.y); ctx.lineTo(pFar.x, pFar.y);
            ctx.fill();
        } else {
            // 靜止
            ctx.fillStyle = '#111'; ctx.globalAlpha = 0.8; ctx.fill();
            ctx.strokeStyle = color; ctx.globalAlpha = 0.3; ctx.stroke();
        }
        
        ctx.globalAlpha = 1;
        ctx.fillStyle = activeKeys[i] ? '#fff' : color;
        ctx.font = 'bold 20px Orbitron';
        ctx.textAlign = 'center';
        ctx.fillText(LANE_KEYS[i], pBot.x + pBot.w/2, pBot.y - 5);
    }

    // 4. 雷射判定線
    const hitL = getCoords(0, 1.0);
    const hitR = getCoords(4, 1.0);
    
    ctx.shadowBlur = 25; ctx.shadowColor = '#00ffff';
    ctx.strokeStyle = 'rgba(0,255,255,0.8)'; ctx.lineWidth = 4;
    ctx.beginPath(); ctx.moveTo(hitL.x - 20, hitL.y); ctx.lineTo(hitR.x + 20, hitR.y); ctx.stroke();
    
    ctx.shadowBlur = 0;
    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();

    // 5. 音符 (光束風格)
    activeNotes.forEach(n => {
        if(n.hit) return;
        // 加上 userOffset 進行校準
        const diff = (n.time + userOffset) - now;
        const progress = 1 - (diff / LEAD_TIME);

        if(progress > 0 && progress < 1.05) {
            const lane = n.lane;
            const color = LANE_COLORS[lane];
            const pHead = getCoords(lane, progress);
            const pTail = getCoords(lane, progress - 0.2); // 長拖尾

            // 繪製光束
            const g = ctx.createLinearGradient(0, pTail.y, 0, pHead.y);
            g.addColorStop(0, 'transparent');
            g.addColorStop(0.4, color);
            g.addColorStop(1, '#fff');

            ctx.fillStyle = g;
            ctx.beginPath();
            ctx.moveTo(pTail.x, pTail.y);
            ctx.lineTo(pTail.x+pTail.w, pTail.y);
            ctx.lineTo(pHead.x+pHead.w, pHead.y);
            ctx.lineTo(pHead.x, pHead.y);
            ctx.fill();

            // 邊框
            ctx.strokeStyle = color; ctx.lineWidth = 1; ctx.stroke();
            // 核心亮線
            ctx.beginPath(); ctx.moveTo(pTail.x+pTail.w/2, pTail.y); ctx.lineTo(pHead.x+pHead.w/2, pHead.y);
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
        }

        if(diff < -200) {
            n.hit = true;
            combo = 0; document.getElementById('combo-num').innerText = 0;
            showJudge("MISS", "#555");
        }
    });

    updateParticles();
    requestAnimationFrame(gameLoop);
}

// --- 粒子 ---
function spawnParticles(lane) {
    const p = getCoords(lane, 1.0);
    const cx = p.x + p.w/2;
    const cy = p.y;
    const c = LANE_COLORS[lane];
    for(let i=0; i<10; i++) particles.push({ x:cx, y:cy, vx:(Math.random()-0.5)*10, vy:(Math.random()-1)*15, life:1, color:c, size:Math.random()*4+2 });
}
function updateParticles() {
    for(let i=particles.length-1; i>=0; i--) {
        let p = particles[i];
        p.x+=p.vx; p.y+=p.vy; p.vy+=0.5; p.life-=0.05;
        if(p.life<=0) particles.splice(i,1);
        else { ctx.globalAlpha=p.life; ctx.fillStyle=p.color; ctx.fillRect(p.x,p.y,p.size,p.size); }
    }
    ctx.globalAlpha=1;
}
function initStars() { for(let i=0; i<150; i++) stars.push({x:Math.random()*canvas.width, y:Math.random()*canvas.height, s:Math.random()*2, o:Math.random(), d:1}); }
function drawStars() {
    ctx.fillStyle='#fff';
    stars.forEach(s=>{ 
        s.o += 0.01 * s.d; if(s.o>1) s.d=-1; if(s.o<0.2) s.d=1;
        ctx.globalAlpha=s.o; ctx.fillRect(s.x,s.y,s.s,s.s);
    });
    ctx.globalAlpha=1;
}

// --- 輸入判定 ---
function handleInput(lane, isDown) {
    activeKeys[lane] = isDown;
    if(isDown && isPlaying) {
        const now = (audioCtx.currentTime * 1000) - startTime + LEAD_TIME;
        // 判定範圍包含 offset
        const note = activeNotes.find(n => !n.hit && n.lane === lane && Math.abs((n.time + userOffset) - now) < 160);
        
        if(note) {
            note.hit = true;
            combo++;
            score += 100 + combo * 10;
            document.getElementById('combo-num').innerText = combo;
            document.getElementById('score').innerText = score.toString().padStart(6,'0');
            
            const el = document.getElementById('combo-num');
            el.style.transform = "scale(1.3)";
            setTimeout(()=>el.style.transform="scale(1)", 100);

            const err = Math.abs((note.time + userOffset) - now);
            if(err < 60) showJudge("PERFECT", "#0ff");
            else showJudge("GOOD", "#ff0");
            
            spawnParticles(lane);
        }
    }
}
function showJudge(txt, col) {
    const el = document.getElementById('judgement');
    el.innerText = txt; el.style.color = col; el.style.opacity = 1; el.style.transform = "scale(1.2)";
    setTimeout(()=>{ el.style.opacity=0; el.style.transform="scale(1)"; }, 200);
}

// 事件
[0,1,2,3].forEach(i => {
    const d = document.getElementById(`z${i}`);
    d.addEventListener('touchstart', (e)=>{ e.preventDefault(); handleInput(i, true); });
    d.addEventListener('touchend', (e)=>{ e.preventDefault(); handleInput(i, false); });
    d.addEventListener('mousedown', (e)=>{ e.preventDefault(); handleInput(i, true); });
    d.addEventListener('mouseup', (e)=>{ e.preventDefault(); handleInput(i, false); });
});
window.addEventListener('keydown', e=>{ const i=LANE_KEYS.indexOf(e.key.toUpperCase()); if(i>=0 && !activeKeys[i]) handleInput(i,true); });
window.addEventListener('keyup', e=>{ const i=LANE_KEYS.indexOf(e.key.toUpperCase()); if(i>=0) handleInput(i,false); });
</script>
</body>
</html>
