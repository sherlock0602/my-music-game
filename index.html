<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Neon Beat - Cyber Core</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

        /* --- 系統重置 --- */
        * { -webkit-tap-highlight-color: transparent; -webkit-touch-callout: none; user-select: none; touch-action: none; box-sizing: border-box; outline: none; }
        body { 
            margin: 0; background: #020205; color: #0ff; overflow: hidden; 
            font-family: 'Share Tech Mono', monospace; 
            width: 100vw; height: 100vh;
            display: flex; justify-content: center; /* 強制置中 */
        }

        /* --- 遊戲主容器 (限制最大寬度，解決手指按不到的問題) --- */
        #game-container {
            position: relative;
            width: 100%;
            max-width: 500px; /* 關鍵：限制最大寬度，平板也好按 */
            height: 100%;
            background: radial-gradient(circle at 50% 30%, #0d1117 0%, #000 90%);
            overflow: hidden;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.1);
            border-left: 1px solid #111;
            border-right: 1px solid #111;
        }

        /* --- 背景裝飾 (科技網格) --- */
        #grid-bg {
            position: absolute; inset: 0; z-index: 0;
            background-image: 
                linear-gradient(transparent 95%, rgba(0, 255, 255, 0.2) 95%),
                linear-gradient(90deg, transparent 95%, rgba(0, 255, 255, 0.2) 95%);
            background-size: 40px 40px;
            transform: perspective(600px) rotateX(60deg);
            transform-origin: center 80%;
            animation: grid-scroll 2s linear infinite;
            opacity: 0.3;
        }
        @keyframes grid-scroll { from { background-position: 0 0; } to { background-position: 0 40px; } }

        /* --- 掃描線特效 (CRT效果) --- */
        .scanline {
            position: absolute; inset: 0; pointer-events: none; z-index: 90;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.1));
            background-size: 100% 4px;
        }

        /* --- HUD 介面 --- */
        #hud-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            pointer-events: none; z-index: 10; padding: 20px;
        }
        
        /* 頂部數據列 */
        .hud-top { display: flex; justify-content: space-between; align-items: flex-start; }
        .hud-box { 
            border: 1px solid rgba(0, 255, 255, 0.3); 
            background: rgba(0, 20, 30, 0.8);
            padding: 5px 10px; clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
        }
        
        #timer-display { font-size: 24px; color: #fff; text-shadow: 0 0 10px #0ff; }
        #timer-label { font-size: 10px; color: #0ff; letter-spacing: 2px; }
        
        #score-display { text-align: right; }
        #score-num { font-size: 20px; color: #fff; }
        #score-label { font-size: 10px; color: #0ff; }

        /* 中間 Combo */
        #center-hud {
            position: absolute; top: 25%; width: 100%; left: 0; text-align: center;
        }
        #combo-num { 
            font-size: 80px; font-weight: bold; margin: 0; color: rgba(255,255,255,0.9);
            text-shadow: 4px 4px 0px rgba(0, 255, 255, 0.2); 
            letter-spacing: -5px; font-style: italic;
        }
        #combo-label { font-size: 14px; letter-spacing: 5px; color: #0ff; opacity: 0.7; }
        
        #judgement { 
            margin-top: 10px; font-size: 32px; font-weight: bold; letter-spacing: 2px;
            text-shadow: 0 0 20px currentColor; opacity: 0; transition: transform 0.05s;
        }

        /* --- 載入層 --- */
        #loader {
            position: absolute; inset: 0; z-index: 100; background: #000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .loading-bar { width: 200px; height: 4px; background: #333; margin-top: 20px; position: relative; overflow: hidden; }
        .loading-fill { position: absolute; left: 0; top: 0; height: 100%; width: 100%; background: #0ff; animation: load-anim 1s infinite translateX(-100%); }
        @keyframes load-anim { 0% { transform: translateX(-100%); } 100% { transform: translateX(100%); } }

        #start-btn {
            margin-top: 30px; padding: 15px 40px; 
            background: transparent; border: 2px solid #0ff; color: #0ff;
            font-family: 'Share Tech Mono'; font-size: 20px; cursor: pointer;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            transition: 0.2s; display: none;
        }
        #start-btn:hover { background: #0ff; color: #000; box-shadow: 0 0 40px #0ff; }

        /* --- 觸控區 (透明，覆蓋在下方) --- */
        #controls-layer {
            position: absolute; bottom: 12%; left: 0; width: 100%; height: 120px;
            display: flex; justify-content: center; align-items: flex-end;
            z-index: 20; gap: 8px; /* 按鈕間距 */
        }
        .touch-pad {
            flex: 1; max-width: 90px; height: 100%;
            /* 邊框除錯用，正式版設為透明但保留點擊反饋 */
            background: linear-gradient(to top, rgba(0, 255, 255, 0.05), transparent);
            border-bottom: 2px solid rgba(0, 255, 255, 0.1);
            border-radius: 4px;
            transition: 0.05s;
            position: relative;
        }
        /* 按下時的效果 */
        .touch-pad.active {
            background: linear-gradient(to top, rgba(0, 255, 255, 0.3), transparent);
            border-bottom: 4px solid #0ff;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.4);
        }
        /* 按鍵標示 */
        .touch-pad::after {
            content: attr(data-key);
            position: absolute; bottom: 10px; width: 100%; text-align: center;
            color: rgba(0, 255, 255, 0.5); font-size: 14px;
        }

        canvas { display: block; position: absolute; inset: 0; z-index: 5; }
    </style>
</head>
<body>

<div id="game-container">
    <div id="grid-bg"></div>
    <div class="scanline"></div>

    <div id="loader">
        <h1 style="font-size: 40px; margin: 0; letter-spacing: 5px; text-shadow: 0 0 20px #0ff;">CYBER BEAT</h1>
        <div style="font-size: 12px; color: #666; margin-top: 5px;">SYSTEM INITIALIZATION</div>
        <div class="loading-bar"><div class="loading-fill"></div></div>
        <div id="status-text" style="margin-top: 10px; font-size: 12px; color: #0ff;">READING DATA...</div>
        <button id="start-btn" onclick="startGame()">INITIATE LINK</button>
    </div>

    <div id="hud-layer">
        <div class="hud-top">
            <div class="hud-box">
                <div id="timer-label">T-MINUS</div>
                <div id="timer-display">00:00</div>
            </div>
            <div class="hud-box">
                <div id="score-label">DATA SYNC</div>
                <div id="score-num">000000</div>
            </div>
        </div>

        <div id="center-hud">
            <div id="combo-num">0</div>
            <div id="combo-label">COMBO</div>
            <div id="judgement">READY</div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="controls-layer">
        <div class="touch-pad" id="btn-0" data-key="D"></div>
        <div class="touch-pad" id="btn-1" data-key="F"></div>
        <div class="touch-pad" id="btn-2" data-key="J"></div>
        <div class="touch-pad" id="btn-3" data-key="K"></div>
    </div>
</div>

<script>
// --- 設定區 ---
const MUSIC_URL = 'music.mp3';
const LEAD_TIME = 1200; // 音符飛行時間 ms
const OFFSET = 0;

// 科技感配色 (黃, 藍, 綠, 紫)
const LANE_COLORS = ['#FFD700', '#00BFFF', '#00FF7F', '#D000FF'];
const LANE_KEYS = ['d', 'f', 'j', 'k'];

// --- 系統變數 ---
const container = document.getElementById('game-container');
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const comboEl = document.getElementById('combo-num');
const scoreEl = document.getElementById('score-num');
const judgeEl = document.getElementById('judgement');
const timerEl = document.getElementById('timer-display');
const statusText = document.getElementById('status-text');
const startBtn = document.getElementById('start-btn');
const loader = document.getElementById('loader');

let audioCtx, audioBuffer, audioSource;
let isPlaying = false, startTime = 0;
let generatedNotes = [], activeNotes = [];
let combo = 0, score = 0;
let activeKeys = [false, false, false, false];
let particles = [];

// 軌道幾何參數
let trackTopW, trackBottomW, trackH, trackY_Start, trackY_End;

// --- 1. 初始化 ---
window.onload = async function() {
    resize();
    window.addEventListener('resize', resize);
    
    try {
        const response = await fetch(MUSIC_URL);
        if (!response.ok) throw new Error("File not found");
        const arrayBuffer = await response.arrayBuffer();
        
        statusText.innerText = "PROCESSING AUDIO WAVEFORM...";
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        audioCtx.decodeAudioData(arrayBuffer, (buffer) => {
            audioBuffer = buffer;
            analyzeBeats(buffer);
        }, () => { throw new Error("Decode Failed"); });
    } catch (err) {
        statusText.style.color = "red";
        statusText.innerText = "ERROR: music.mp3 MISSING";
    }
};

// --- 2. 佈局計算 (關鍵：確保按鈕對齊) ---
function resize() {
    // 讓 Canvas 大小等於容器大小 (容器已經限制了 max-width 500px)
    const rect = container.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;

    // 設定軌道參數
    trackY_Start = canvas.height * 0.2; // 消失點
    trackY_End = canvas.height * 0.85;  // 判定線位置
    trackH = trackY_End - trackY_Start;
    
    trackTopW = canvas.width * 0.1;     // 頂部寬度
    trackBottomW = canvas.width * 0.95; // 底部寬度 (稍微留邊)

    // 調整按鈕區域位置以對齊判定線
    // 注意：CSS 的 .touch-pad 是 flex 自動均分的，這裡我們只需要視覺上對齊即可
    // 由於我們限制了容器寬度，並讓軌道幾乎佔滿底部，按鈕自然會對齊
}

// --- 3. 節拍分析 ---
function analyzeBeats(buffer) {
    const rawData = buffer.getChannelData(0);
    const sampleRate = buffer.sampleRate;
    const step = Math.floor(sampleRate / 60); 
    
    generatedNotes = [];
    let sum = 0;
    for (let i = 0; i < rawData.length; i += step) sum += Math.abs(rawData[i]);
    const threshold = (sum / (rawData.length/step)) * 1.6;

    let lastIndex = -10000;
    const minDist = sampleRate * 0.3; 

    for (let i = 0; i < rawData.length; i += step) {
        if (Math.abs(rawData[i]) > threshold && (i - lastIndex) > minDist) {
            generatedNotes.push({
                time: (i / sampleRate) * 1000,
                lane: Math.floor(Math.random() * 4),
                hit: false
            });
            lastIndex = i;
        }
    }
    
    statusText.innerText = "SYSTEM READY";
    document.querySelector('.loading-bar').style.display = 'none';
    startBtn.style.display = 'block';
}

// --- 4. 遊戲循環 ---
function startGame() {
    if(!audioBuffer) return;
    loader.style.opacity = 0;
    setTimeout(() => loader.style.display = 'none', 500);

    activeNotes = JSON.parse(JSON.stringify(generatedNotes));
    audioSource = audioCtx.createBufferSource();
    audioSource.buffer = audioBuffer;
    audioSource.connect(audioCtx.destination);
    
    startTime = audioCtx.currentTime * 1000 + LEAD_TIME;
    audioSource.start(audioCtx.currentTime + (LEAD_TIME / 1000));
    
    isPlaying = true;
    requestAnimationFrame(gameLoop);
}

// 透視投影函數
function getLaneCoords(lane, progress) {
    const y = trackY_Start + (trackH * progress);
    const currentTotalW = trackTopW + (trackBottomW - trackTopW) * progress;
    const laneW = currentTotalW / 4;
    const startX = (canvas.width - currentTotalW) / 2;
    const x = startX + (lane * laneW);
    return { x, y, w: laneW };
}

function gameLoop() {
    if(!isPlaying) return;
    const now = (audioCtx.currentTime * 1000) - startTime + LEAD_TIME;

    // --- 邏輯更新 ---
    if(audioBuffer) {
        let remaining = audioBuffer.duration - (audioCtx.currentTime - (startTime/1000) + (LEAD_TIME/1000));
        if (remaining < 0) { remaining = 0; isPlaying = false; }
        const m = Math.floor(remaining / 60);
        const s = Math.floor(remaining % 60);
        timerEl.innerText = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
    }

    // --- 繪圖 ---
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 1. 繪製軌道線 (科技感)
    ctx.lineWidth = 1;
    ctx.strokeStyle = 'rgba(0, 255, 255, 0.2)';
    
    // 垂直分隔線
    for(let i=0; i<=4; i++) {
        const pStart = getLaneCoords(i, 0);
        const pEnd = getLaneCoords(i, 1.2); // 延伸到底部
        ctx.beginPath();
        ctx.moveTo(pStart.x, pStart.y);
        ctx.lineTo(pEnd.x, pEnd.y);
        ctx.stroke();
    }

    // 2. 判定線 (雷射掃描)
    const hitLeft = getLaneCoords(0, 1.0);
    const hitRight = getLaneCoords(4, 1.0); // 實際上是第4軌的右邊界
    
    // 軌道底部光暈
    ctx.save();
    ctx.shadowBlur = 20;
    ctx.shadowColor = '#0ff';
    ctx.strokeStyle = '#0ff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(hitLeft.x, hitLeft.y);
    ctx.lineTo(hitRight.x + hitRight.w, hitRight.y); // 注意這裡的寬度計算差異，修正如下
    // getLaneCoords(4) 回傳的是第5條線的位置，所以直接用 x 即可
    const pRightEdge = getLaneCoords(4, 1.0);
    
    ctx.beginPath();
    ctx.moveTo(hitLeft.x, hitLeft.y);
    ctx.lineTo(pRightEdge.x, pRightEdge.y);
    ctx.stroke();
    ctx.restore();

    // 3. 軌道按壓回饋
    activeKeys.forEach((active, i) => {
        if(active) {
            const p1 = getLaneCoords(i, 0);
            const p2 = getLaneCoords(i, 1.0);
            const color = LANE_COLORS[i];
            
            // 繪製梯形光束
            const grad = ctx.createLinearGradient(0, p2.y, 0, p1.y);
            grad.addColorStop(0, color);
            grad.addColorStop(1, 'transparent');
            
            ctx.fillStyle = grad;
            ctx.globalAlpha = 0.3;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p1.x + p1.w, p1.y);
            ctx.lineTo(p2.x + p2.w, p2.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.fill();
            ctx.globalAlpha = 1;
            
            // 底部高亮條
            ctx.fillStyle = color;
            ctx.fillRect(p2.x, p2.y - 2, p2.w, 4);
        }
    });

    // 4. 音符 (數位訊號塊)
    activeNotes.forEach(n => {
        if(n.hit) return;
        const diff = (n.time + OFFSET) - now;
        const progress = 1 - (diff / LEAD_TIME);

        if(progress > 0 && progress < 1.1) {
            const p = getLaneCoords(n.lane, progress);
            const color = LANE_COLORS[n.lane];

            // 繪製音符 (扁平科技方塊)
            const noteH = p.w * 0.4; // 高度
            const y = p.y - noteH; 
            
            ctx.fillStyle = color;
            ctx.shadowBlur = 15;
            ctx.shadowColor = color;
            
            // 內縮一點，讓它看起來懸浮
            const padding = p.w * 0.1;
            ctx.fillRect(p.x + padding, y, p.w - padding*2, noteH);
            
            // 核心亮紋
            ctx.fillStyle = '#fff';
            ctx.shadowBlur = 0;
            ctx.fillRect(p.x + padding, y + noteH*0.4, p.w - padding*2, noteH*0.2);
        }

        if (diff < -150) {
            n.hit = true;
            combo = 0; comboEl.innerText = 0;
            showJudge("MISS", "#555");
        }
    });

    // 5. 粒子
    updateParticles();

    requestAnimationFrame(gameLoop);
}

// --- 粒子特效 (像素碎片) ---
function spawnParticles(lane) {
    const p = getLaneCoords(lane, 1.0);
    const cx = p.x + p.w/2;
    const cy = p.y;
    const color = LANE_COLORS[lane];

    for(let i=0; i<8; i++) {
        particles.push({
            x: cx, y: cy,
            vx: (Math.random() - 0.5) * 10,
            vy: (Math.random() - 1) * 15,
            size: Math.random() * 4 + 2,
            life: 1.0,
            color: color
        });
    }
}

function updateParticles() {
    for(let i=particles.length-1; i>=0; i--) {
        let p = particles[i];
        p.x += p.vx; p.y += p.vy; p.vy += 0.8; p.life -= 0.05;
        
        if(p.life <= 0) particles.splice(i, 1);
        else {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            // 畫正方形像素
            ctx.fillRect(p.x, p.y, p.size, p.size);
        }
    }
    ctx.globalAlpha = 1;
}

// --- 輸入處理 ---
function handleInput(lane, isDown) {
    if(lane < 0 || lane >= 4) return;
    activeKeys[lane] = isDown;
    
    // UI 反饋
    const btn = document.getElementById(`btn-${lane}`);
    if(isDown) btn.classList.add('active');
    else btn.classList.remove('active');

    if(isDown && isPlaying) {
        const now = (audioCtx.currentTime * 1000) - startTime + LEAD_TIME;
        const note = activeNotes.find(n => !n.hit && n.lane === lane && Math.abs((n.time + OFFSET) - now) < 160);
        
        if(note) {
            note.hit = true;
            combo++;
            score += 150;
            comboEl.innerText = combo;
            scoreEl.innerText = score.toString().padStart(6, '0');
            
            // Combo 跳動
            comboEl.style.transform = "scale(1.5)";
            setTimeout(() => comboEl.style.transform = "scale(1)", 100);

            // 判定
            const diff = Math.abs((note.time + OFFSET) - now);
            if(diff < 50) showJudge("PERFECT", "#0ff");
            else showJudge("GOOD", "#ff0");

            spawnParticles(lane);
        }
    }
}

function showJudge(text, color) {
    judgeEl.innerText = text;
    judgeEl.style.color = color;
    judgeEl.style.opacity = 1;
    judgeEl.style.transform = "scale(1.2)";
    setTimeout(() => { judgeEl.style.opacity = 0; judgeEl.style.transform = "scale(1)"; }, 150);
}

// 事件綁定
LANE_KEYS.forEach((k, i) => {
    const el = document.getElementById(`btn-${i}`);
    el.addEventListener('touchstart', (e)=>{ e.preventDefault(); handleInput(i, true); });
    el.addEventListener('touchend', (e)=>{ e.preventDefault(); handleInput(i, false); });
    el.addEventListener('mousedown', (e)=>{ e.preventDefault(); handleInput(i, true); });
    el.addEventListener('mouseup', (e)=>{ e.preventDefault(); handleInput(i, false); });
});
window.addEventListener('keydown', e => {
    const i = LANE_KEYS.indexOf(e.key.toLowerCase());
    if(i > -1 && !activeKeys[i]) handleInput(i, true);
});
window.addEventListener('keyup', e => {
    const i = LANE_KEYS.indexOf(e.key.toLowerCase());
    if(i > -1) handleInput(i, false);
});
</script>
</body>
</html>
